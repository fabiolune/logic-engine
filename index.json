{
  "api/LogicEngine.CompiledCatalog-1.html": {
    "href": "api/LogicEngine.CompiledCatalog-1.html",
    "title": "Class CompiledCatalog<T> | Logic Engine",
    "summary": "Class CompiledCatalog<T> Namespace LogicEngine Assembly LogicEngine.dll Represents a compiled catalog of rules that can be applied to items of type T. public record CompiledCatalog<T> : IAppliable<T>, IDetailedAppliable<T, IEnumerable<string>>, IAppliedSelector<T, string>, IEquatable<CompiledCatalog<T>> where T : new() Type Parameters T The type of items to which the catalog's rules are applied. Must have a parameterless constructor. Inheritance object CompiledCatalog<T> Implements IAppliable<T> IDetailedAppliable<T, IEnumerable<string>> IAppliedSelector<T, string> IEquatable<CompiledCatalog<T>> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This catalog provides functionality to apply rules to an item, retrieve detailed results of rule application, and identify the first matching rule for a given item. It is constructed from a set of compiled rule sets. Constructors CompiledCatalog(CompiledRulesSet<T>[], string) Represents a compiled catalog of rules, providing functionality to apply rules, retrieve detailed results, and find the first matching rule. public CompiledCatalog(CompiledRulesSet<T>[] ruleSets, string name) Parameters ruleSets CompiledRulesSet<T>[] An array of compiled rule sets. Each rule set is evaluated and included in the catalog if it contains valid rules. name string The name of the catalog. Remarks The catalog is initialized with the provided rule sets, filtering out any invalid or empty rule sets. If no valid rule sets are provided, default functions are used for applying rules, retrieving detailed results, and finding the first matching rule. Properties Name public string Name { get; } Property Value string Methods Apply(T) Applies the specified operation to the given item and returns the result. public bool Apply(T item) Parameters item T The item to which the operation is applied. Returns bool true if the operation succeeds; otherwise, false. DetailedApply(T) Applies the specified item and returns either a collection of error messages or a success indicator. public Either<IEnumerable<string>, Unit> DetailedApply(T item) Parameters item T The item to be applied. Cannot be null. Returns Either<IEnumerable<string>, Unit> An TinyFp.Either<L, R> containing a collection of error messages if the operation fails, or a TinyFp.Unit value if the operation succeeds. Remarks Use this method to apply an item and handle potential errors in a detailed manner. The left side of the result contains error messages describing the issues encountered, while the right side indicates a successful operation. FirstMatching(T) Finds the first matching string for the specified item. public Option<string> FirstMatching(T item) Parameters item T The item to match against. Returns Option<string> An TinyFp.Option<A> containing the first matching string if a match is found; otherwise, an empty TinyFp.Option<A>. Remarks The method uses the provided item to determine a match and returns the first result. The behavior of the matching logic depends on the implementation of the underlying _firstMatching function."
  },
  "api/LogicEngine.CompiledRule-1.html": {
    "href": "api/LogicEngine.CompiledRule-1.html",
    "title": "Class CompiledRule<T> | Logic Engine",
    "summary": "Class CompiledRule<T> Namespace LogicEngine Assembly LogicEngine.dll Represents a compiled rule that can be applied to an object of type T. public record CompiledRule<T> : IAppliable<T>, IDetailedAppliable<T, string>, IEquatable<CompiledRule<T>> where T : new() Type Parameters T The type of object to which the rule can be applied. Must have a parameterless constructor. Inheritance object CompiledRule<T> Implements IAppliable<T> IDetailedAppliable<T, string> IEquatable<CompiledRule<T>> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class provides functionality to evaluate a rule against an object of type T and optionally retrieve detailed information about the evaluation result. Constructors CompiledRule(Func<T, bool>, string) Represents a compiled rule that can be executed against a specified input. public CompiledRule(Func<T, bool> executable, string code) Parameters executable Func<T, bool> A function that defines the rule logic and determines whether the input satisfies the rule. code string A string representing the unique code or identifier for the rule. Properties Code The code that represents the rule public string Code { get; } Property Value string Methods Apply(T) Applies the specified condition or operation to the given item. public bool Apply(T item) Parameters item T The item to which the condition or operation is applied. Returns bool true if the condition or operation succeeds; otherwise, false. DetailedApply(T) Applies the specified operation to the given item and returns the result as an TinyFp.Either<L, R>. public Either<string, Unit> DetailedApply(T item) Parameters item T The item to which the operation will be applied. Returns Either<string, Unit> An TinyFp.Either<L, R> containing a string with an error message if the operation fails, or a TinyFp.Unit value if the operation succeeds."
  },
  "api/LogicEngine.CompiledRulesSet-1.html": {
    "href": "api/LogicEngine.CompiledRulesSet-1.html",
    "title": "Class CompiledRulesSet<T> | Logic Engine",
    "summary": "Class CompiledRulesSet<T> Namespace LogicEngine Assembly LogicEngine.dll Represents a compiled set of rules that can be applied to items of type T. public record CompiledRulesSet<T> : IAppliable<T>, IDetailedAppliable<T, IEnumerable<string>>, IAppliedSelector<T, string>, IEquatable<CompiledRulesSet<T>> where T : new() Type Parameters T The type of items to which the rules are applied. Must have a parameterless constructor. Inheritance object CompiledRulesSet<T> Implements IAppliable<T> IDetailedAppliable<T, IEnumerable<string>> IAppliedSelector<T, string> IEquatable<CompiledRulesSet<T>> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class provides functionality to apply a set of compiled rules to an item, check detailed results of rule application, and retrieve the first matching rule. It implements the IAppliable<T>, IDetailedAppliable<T, TOut>, and IAppliedSelector<TIn, TOut> interfaces. Constructors CompiledRulesSet(CompiledRule<T>[], string) Represents a compiled set of rules that can be applied to evaluate conditions and retrieve results. public CompiledRulesSet(CompiledRule<T>[] rules, string name) Parameters rules CompiledRule<T>[] An array of compiled rules to include in the set. Must not be empty. If empty, default functions are used. name string The name of the compiled rules set. This is used to identify the set. Remarks The CompiledRulesSet<T> class initializes a set of rules that can be applied to input data. If the provided rules array is empty, default functions are used for rule evaluation. Properties Name public string Name { get; } Property Value string Methods Apply(T) Applies the specified operation to the given item and returns the result. public bool Apply(T item) Parameters item T The item to which the operation is applied. Returns bool true if the operation succeeds; otherwise, false. DetailedApply(T) Applies the specified operation to the given item and returns either a collection of error messages or a success indicator. public Either<IEnumerable<string>, Unit> DetailedApply(T item) Parameters item T The item to which the operation is applied. Cannot be null. Returns Either<IEnumerable<string>, Unit> An TinyFp.Either<L, R> containing a collection of error messages if the operation fails, or a TinyFp.Unit value indicating success if the operation completes successfully. Remarks Use this method to perform an operation on the provided item while capturing detailed error information in case of failure. The returned TinyFp.Either<L, R> allows callers to handle success and failure cases explicitly. FirstMatching(T) Finds the first matching string for the specified item. public Option<string> FirstMatching(T item) Parameters item T The item to match against. Returns Option<string> An TinyFp.Option<A> containing the first matching string if a match is found; otherwise, an empty TinyFp.Option<A>. Remarks The method uses the provided item to determine a match and returns the first result. If no match is found, the returned TinyFp.Option<A> will be empty."
  },
  "api/LogicEngine.Compilers.RuleCompiler.html": {
    "href": "api/LogicEngine.Compilers.RuleCompiler.html",
    "title": "Class RuleCompiler | Logic Engine",
    "summary": "Class RuleCompiler Namespace LogicEngine.Compilers Assembly LogicEngine.dll public class RuleCompiler : IRuleCompiler Inheritance object RuleCompiler Implements IRuleCompiler Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Compile<T>(Rule) Compiles a rule into a strongly-typed, executable representation. public Option<CompiledRule<T>> Compile<T>(Rule rule) where T : new() Parameters rule Rule The rule to compile. This must be a valid rule that can be transformed into a compiled representation. Returns Option<CompiledRule<T>> An TinyFp.Option<A> containing a CompiledRule<T> if the compilation succeeds; otherwise, an empty option if the rule cannot be compiled. Type Parameters T The type of the object that the compiled rule will evaluate. Must have a parameterless constructor. Remarks The compiled rule includes both a delegate for evaluating the rule and the original code representation."
  },
  "api/LogicEngine.Compilers.RulesCatalogCompiler.html": {
    "href": "api/LogicEngine.Compilers.RulesCatalogCompiler.html",
    "title": "Class RulesCatalogCompiler | Logic Engine",
    "summary": "Class RulesCatalogCompiler Namespace LogicEngine.Compilers Assembly LogicEngine.dll public class RulesCatalogCompiler : IRulesCatalogCompiler Inheritance object RulesCatalogCompiler Implements IRulesCatalogCompiler Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RulesCatalogCompiler(IRulesSetCompiler) public RulesCatalogCompiler(IRulesSetCompiler rulesSetCompiler) Parameters rulesSetCompiler IRulesSetCompiler Methods Compile<T>(RulesCatalog) Compiles a rules catalog into a compiled catalog for the specified type. public Option<CompiledCatalog<T>> Compile<T>(RulesCatalog catalog) where T : new() Parameters catalog RulesCatalog The rules catalog to compile. Must not be null and must contain valid rule sets. Returns Option<CompiledCatalog<T>> An TinyFp.Option<A> containing a CompiledCatalog<T> if the compilation is successful; otherwise, an empty option if no valid rule sets are found. Type Parameters T The type of the objects that the compiled catalog will operate on. Must have a parameterless constructor. Remarks This method filters and compiles the rule sets in the provided catalog, producing a compiled catalog that can be used for rule evaluation. If no valid rule sets are found, the method returns an empty option."
  },
  "api/LogicEngine.Compilers.RulesSetCompiler.html": {
    "href": "api/LogicEngine.Compilers.RulesSetCompiler.html",
    "title": "Class RulesSetCompiler | Logic Engine",
    "summary": "Class RulesSetCompiler Namespace LogicEngine.Compilers Assembly LogicEngine.dll public class RulesSetCompiler : IRulesSetCompiler Inheritance object RulesSetCompiler Implements IRulesSetCompiler Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RulesSetCompiler(IRuleCompiler) public RulesSetCompiler(IRuleCompiler singleRuleCompiler) Parameters singleRuleCompiler IRuleCompiler Methods Compile<T>(RulesSet) Compiles a set of rules into a compiled rules set for the specified type. public Option<CompiledRulesSet<T>> Compile<T>(RulesSet set) where T : new() Parameters set RulesSet The set of rules to compile. Cannot be null. Returns Option<CompiledRulesSet<T>> An TinyFp.Option<A> containing a CompiledRulesSet<T> if the compilation is successful, or an empty option if no rules are compiled. Type Parameters T The type of object the rules will operate on. Must have a parameterless constructor. Remarks This method processes the rules in the provided set by compiling each rule individually, filtering out invalid or uncompiled rules, and then aggregating the results into a compiled rules set."
  },
  "api/LogicEngine.Compilers.html": {
    "href": "api/LogicEngine.Compilers.html",
    "title": "Namespace LogicEngine.Compilers | Logic Engine",
    "summary": "Namespace LogicEngine.Compilers Classes RuleCompiler RulesCatalogCompiler RulesSetCompiler"
  },
  "api/LogicEngine.Extensions.EnumerableExtensions.html": {
    "href": "api/LogicEngine.Extensions.EnumerableExtensions.html",
    "title": "Class EnumerableExtensions | Logic Engine",
    "summary": "Class EnumerableExtensions Namespace LogicEngine.Extensions Assembly LogicEngine.dll public static class EnumerableExtensions Inheritance object EnumerableExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Filter<T>(IEnumerable<T>, IAppliable<T>) Filters the elements of the specified enumerable based on a condition defined by the provided IAppliable<T> implementation. public static IEnumerable<T> Filter<T>(this IEnumerable<T> enumerable, IAppliable<T> app) where T : new() Parameters enumerable IEnumerable<T> The source enumerable to filter. Cannot be null. app IAppliable<T> An implementation of IAppliable<T> that defines the condition to apply to each element. Cannot be null. Returns IEnumerable<T> An IEnumerable<T> containing elements from the source enumerable that satisfy the condition defined by app. Type Parameters T The type of elements in the enumerable. Must have a parameterless constructor. Remarks This method uses the Apply(T) method to determine whether each element in the source enumerable should be included in the result. FirstOrDefault<T>(IEnumerable<T>, IAppliable<T>) Returns the first element in the sequence that satisfies the specified condition, or the default value if no such element is found. public static T FirstOrDefault<T>(this IEnumerable<T> @this, IAppliable<T> app) where T : new() Parameters this IEnumerable<T> The sequence to search. app IAppliable<T> An object implementing IAppliable<T> that defines the condition to apply to each element. Returns T The first element in the sequence that satisfies the condition defined by app. If no such element is found, a new instance of T is returned. Type Parameters T The type of the elements in the sequence. Must have a parameterless constructor."
  },
  "api/LogicEngine.Extensions.html": {
    "href": "api/LogicEngine.Extensions.html",
    "title": "Namespace LogicEngine.Extensions | Logic Engine",
    "summary": "Namespace LogicEngine.Extensions Classes EnumerableExtensions"
  },
  "api/LogicEngine.Interfaces.Compilers.IRuleCompiler.html": {
    "href": "api/LogicEngine.Interfaces.Compilers.IRuleCompiler.html",
    "title": "Interface IRuleCompiler | Logic Engine",
    "summary": "Interface IRuleCompiler Namespace LogicEngine.Interfaces.Compilers Assembly LogicEngine.dll public interface IRuleCompiler Methods Compile<T>(Rule) Compiles a rule into a compiled rule, None if the rule is invalid Option<CompiledRule<T>> Compile<T>(Rule rule) where T : new() Parameters rule Rule Returns Option<CompiledRule<T>> Type Parameters T"
  },
  "api/LogicEngine.Interfaces.Compilers.IRulesCatalogCompiler.html": {
    "href": "api/LogicEngine.Interfaces.Compilers.IRulesCatalogCompiler.html",
    "title": "Interface IRulesCatalogCompiler | Logic Engine",
    "summary": "Interface IRulesCatalogCompiler Namespace LogicEngine.Interfaces.Compilers Assembly LogicEngine.dll public interface IRulesCatalogCompiler Methods Compile<T>(RulesCatalog) Compiles a catalog of rules into a compiled catalog, None if the catalog is invalid Option<CompiledCatalog<T>> Compile<T>(RulesCatalog catalog) where T : new() Parameters catalog RulesCatalog Returns Option<CompiledCatalog<T>> Type Parameters T"
  },
  "api/LogicEngine.Interfaces.Compilers.IRulesSetCompiler.html": {
    "href": "api/LogicEngine.Interfaces.Compilers.IRulesSetCompiler.html",
    "title": "Interface IRulesSetCompiler | Logic Engine",
    "summary": "Interface IRulesSetCompiler Namespace LogicEngine.Interfaces.Compilers Assembly LogicEngine.dll public interface IRulesSetCompiler Methods Compile<T>(RulesSet) Compiles a rule set into a compiled rule set, None if the rule set is invalid Option<CompiledRulesSet<T>> Compile<T>(RulesSet set) where T : new() Parameters set RulesSet Returns Option<CompiledRulesSet<T>> Type Parameters T"
  },
  "api/LogicEngine.Interfaces.Compilers.html": {
    "href": "api/LogicEngine.Interfaces.Compilers.html",
    "title": "Namespace LogicEngine.Interfaces.Compilers | Logic Engine",
    "summary": "Namespace LogicEngine.Interfaces.Compilers Interfaces IRuleCompiler IRulesCatalogCompiler IRulesSetCompiler"
  },
  "api/LogicEngine.Interfaces.IAppliable-1.html": {
    "href": "api/LogicEngine.Interfaces.IAppliable-1.html",
    "title": "Interface IAppliable<T> | Logic Engine",
    "summary": "Interface IAppliable<T> Namespace LogicEngine.Interfaces Assembly LogicEngine.dll public interface IAppliable<in T> where T : new() Type Parameters T Methods Apply(T) Applies the item to the appliable bool Apply(T item) Parameters item T Returns bool"
  },
  "api/LogicEngine.Interfaces.IAppliedSelector-2.html": {
    "href": "api/LogicEngine.Interfaces.IAppliedSelector-2.html",
    "title": "Interface IAppliedSelector<TIn, TOut> | Logic Engine",
    "summary": "Interface IAppliedSelector<TIn, TOut> Namespace LogicEngine.Interfaces Assembly LogicEngine.dll public interface IAppliedSelector<TIn, TOut> where TIn : new() Type Parameters TIn TOut Methods FirstMatching(TIn) Returns the first matching item Option<TOut> FirstMatching(TIn item) Parameters item TIn Returns Option<TOut>"
  },
  "api/LogicEngine.Interfaces.IDetailedAppliable-2.html": {
    "href": "api/LogicEngine.Interfaces.IDetailedAppliable-2.html",
    "title": "Interface IDetailedAppliable<T, TOut> | Logic Engine",
    "summary": "Interface IDetailedAppliable<T, TOut> Namespace LogicEngine.Interfaces Assembly LogicEngine.dll public interface IDetailedAppliable<T, TOut> where T : new() Type Parameters T TOut Methods DetailedApply(T) Applies the item to the appliable Either<TOut, Unit> DetailedApply(T item) Parameters item T Returns Either<TOut, Unit>"
  },
  "api/LogicEngine.Interfaces.html": {
    "href": "api/LogicEngine.Interfaces.html",
    "title": "Namespace LogicEngine.Interfaces | Logic Engine",
    "summary": "Namespace LogicEngine.Interfaces Interfaces IAppliable<T> IAppliedSelector<TIn, TOut> IDetailedAppliable<T, TOut>"
  },
  "api/LogicEngine.Internals.OperatorType.html": {
    "href": "api/LogicEngine.Internals.OperatorType.html",
    "title": "Enum OperatorType | Logic Engine",
    "summary": "Enum OperatorType Namespace LogicEngine.Internals Assembly LogicEngine.dll public enum OperatorType Fields Contains = 11 Item parameter contains specified constant ContainsKey = 15 Item parameter dictionary property contains the given key ContainsValue = 17 Item parameter dictionary property contains the given value Equal = 1 Item parameter is equal to specified constant GreaterThan = 6 Item parameter greater than specified constant GreaterThanOrEqual = 7 Item parameter greater or equal than specified constant InnerContains = 29 Item parameter array contains another item parameter InnerEqual = 23 Item parameter equal to another item parameter InnerGreaterThan = 24 Item parameter greater than another item parameter InnerGreaterThanOrEqual = 25 Item parameter greater or equal than another item parameter InnerLessThan = 26 Item parameter less than another item parameter InnerLessThanOrEqual = 27 Item parameter less or equal than another item parameter InnerNotContains = 30 Item parameter array does not contain another item parameter InnerNotEqual = 28 Item parameter not equal to another item parameter InnerNotOverlaps = 32 Item parameter array does not overlap another array parameter InnerOverlaps = 31 Item parameter array overlaps another array parameter IsContained = 21 Item parameter is contained into specified constant array IsNotContained = 22 Item parameter is not contained into specified constant array KeyContainsValue = 19 Item parameter dictionary has the given value for the specified key LessThan = 8 Item parameter less than specified constant LessThanOrEqual = 9 Item parameter less or equal than specified constant None = 0 NotContains = 12 Item parameter not contains specified constant NotContainsKey = 16 Item parameter dictionary property does not contain the given key NotContainsValue = 18 Item parameter dictionary property does not contain the given value NotEqual = 10 Item parameter not equal to specified constant NotKeyContainsValue = 20 Item parameter dictionary has not the given value for the specified key NotOverlaps = 14 Item parameter does not have intersections with specified enumerable constant Overlaps = 13 Item parameter has intersection with specified enumerable constant StringContains = 4 Item parameter string contains specified constant StringEndsWith = 3 Item parameter string ends with specified constant StringRegexIsMatch = 5 Item parameter string matches specified regex StringStartsWith = 2 Item parameter string starts with specified constant"
  },
  "api/LogicEngine.Internals.html": {
    "href": "api/LogicEngine.Internals.html",
    "title": "Namespace LogicEngine.Internals | Logic Engine",
    "summary": "Namespace LogicEngine.Internals Enums OperatorType"
  },
  "api/LogicEngine.Models.Rule.html": {
    "href": "api/LogicEngine.Models.Rule.html",
    "title": "Class Rule | Logic Engine",
    "summary": "Class Rule Namespace LogicEngine.Models Assembly LogicEngine.dll public record Rule : IEquatable<Rule> Inheritance object Rule Implements IEquatable<Rule> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors Rule(string, OperatorType, string, string) public Rule(string property, OperatorType type, string value, string code) Parameters property string type OperatorType value string code string Properties Code Code to return if the rule is not satisfied [DataMember(Name = \"code\")] [Required] public string Code { get; init; } Property Value string Operator Operator to apply to the property [DataMember(Name = \"operator\")] [Required] public OperatorType Operator { get; init; } Property Value OperatorType Property Name of the property the rule is applied to [DataMember(Name = \"property\")] [Required] public string Property { get; init; } Property Value string Value Value to compare the property to or name of the property to compare with Property [DataMember(Name = \"value\")] [Required] public string Value { get; init; } Property Value string Methods ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object."
  },
  "api/LogicEngine.Models.RulesCatalog.html": {
    "href": "api/LogicEngine.Models.RulesCatalog.html",
    "title": "Class RulesCatalog | Logic Engine",
    "summary": "Class RulesCatalog Namespace LogicEngine.Models Assembly LogicEngine.dll public record RulesCatalog : IEquatable<RulesCatalog> Inheritance object RulesCatalog Implements IEquatable<RulesCatalog> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RulesCatalog(IEnumerable<RulesSet>, string) Initializes a new instance of the RulesCatalog class with the specified rules sets and name. public RulesCatalog(IEnumerable<RulesSet> rulesSets, string name) Parameters rulesSets IEnumerable<RulesSet> A collection of RulesSet objects that define the rules contained in the catalog. This parameter cannot be null. name string The name of the rules catalog. This parameter cannot be null or empty. Properties Name public string Name { get; } Property Value string RulesSets Rules sets that make up the catalog public IEnumerable<RulesSet> RulesSets { get; } Property Value IEnumerable<RulesSet> Operators operator +(RulesCatalog, RulesCatalog) Combines two RulesCatalog instances into a single catalog containing the rules from both. public static RulesCatalog operator +(RulesCatalog catalog1, RulesCatalog catalog2) Parameters catalog1 RulesCatalog The first RulesCatalog to combine. catalog2 RulesCatalog The second RulesCatalog to combine. Returns RulesCatalog A new RulesCatalog that contains the combined rule sets from both catalogs. Remarks The resulting catalog will include all rule sets from catalog1 and catalog2. The name of the resulting catalog will be a combination of the names of the input catalogs, formatted as \"(Name1 OR Name2)\". operator *(RulesCatalog, RulesCatalog) Combines two RulesCatalog instances by applying a logical AND operation to their respective rule sets. public static RulesCatalog operator *(RulesCatalog catalog1, RulesCatalog catalog2) Parameters catalog1 RulesCatalog The first RulesCatalog to combine. catalog2 RulesCatalog The second RulesCatalog to combine. Returns RulesCatalog A new RulesCatalog instance containing the combined rule sets of catalog1 and catalog2, with a name indicating the logical AND operation. Remarks This operator creates a new RulesCatalog where each rule in catalog1 is combined with each rule in catalog2 using their respective multiplication logic. The resulting catalog's name reflects the combination of the two input catalogs."
  },
  "api/LogicEngine.Models.RulesSet.html": {
    "href": "api/LogicEngine.Models.RulesSet.html",
    "title": "Class RulesSet | Logic Engine",
    "summary": "Class RulesSet Namespace LogicEngine.Models Assembly LogicEngine.dll public record RulesSet : IEquatable<RulesSet> Inheritance object RulesSet Implements IEquatable<RulesSet> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RulesSet(IEnumerable<Rule>, string) Initializes a new instance of the RulesSet class with the specified rules and name. public RulesSet(IEnumerable<Rule> rules, string name) Parameters rules IEnumerable<Rule> A collection of Rule objects that define the rules for this set. Cannot be null. name string The name of the rules set. Cannot be null or empty. Properties Name public string Name { get; } Property Value string Rules Rules that make up the set [DataMember(Name = \"rules\")] [Required] public IEnumerable<Rule> Rules { get; init; } Property Value IEnumerable<Rule> Operators operator *(RulesSet, RulesSet) Combines two RulesSet instances into a new RulesSet that contains the concatenated rules and a combined name. public static RulesSet operator *(RulesSet set1, RulesSet set2) Parameters set1 RulesSet The first RulesSet to combine. set2 RulesSet The second RulesSet to combine. Returns RulesSet A new RulesSet that contains the rules from both set1 and set2, and a name representing their logical combination."
  },
  "api/LogicEngine.Models.html": {
    "href": "api/LogicEngine.Models.html",
    "title": "Namespace LogicEngine.Models | Logic Engine",
    "summary": "Namespace LogicEngine.Models Classes Rule RulesCatalog RulesSet"
  },
  "api/LogicEngine.html": {
    "href": "api/LogicEngine.html",
    "title": "Namespace LogicEngine | Logic Engine",
    "summary": "Namespace LogicEngine Classes CompiledCatalog<T> Represents a compiled catalog of rules that can be applied to items of type T. CompiledRule<T> Represents a compiled rule that can be applied to an object of type T. CompiledRulesSet<T> Represents a compiled set of rules that can be applied to items of type T."
  },
  "docs/logic-engine.html": {
    "href": "docs/logic-engine.html",
    "title": "Logic Engine | Logic Engine",
    "summary": "Logic Engine Table of contents The Rule The Operators Direct operators Internal direct operators String direct operators Enumerable operators Internal enumerable operators Key-value operators Inverse enumerable operators Inverse enumerable operators The RulesSets The RulesCatalog The Algebraic model RulesSets product RulesCatalog sum RulesCatalog product Compilers and compiled objects Known limitations Breaking changes How to install the package The Rule The rule object represents the building block for the system. A rule is an abstraction for a function acting on the value of a type and returning a boolean response. DEFINITION: A Rule is satisfied by an item t of type T if the associated function f: T ──► bool returns true if f(t) is true. Given a type to be applied to, a rule is defined by a set of fields Property: identifies the property against which to execute the evaluation Operator: defines the operation to execute on the property Value: identifies the value against which the result of the operator on the property should be compared Code: the error code to be generated when the rules applied on an object fail (returns false) The Operators The Operator can assume different possible values depending on the Property it is applied to and on the value, the result should be compared to. Operators are classified based on the way they work and their behavior. The rules categorization is also influenced by some implementation details. Direct operators These operators directly compare the Property to the Value considered as a constant: Equal: equality on value types (strings, numbers, ...) NotEqual: inequality on value types (strings, numbers, ...) GreaterThan: only applies to numbers GreaterThanOrEqual: only applies to numbers LessThan: only applies to numbers LessThanOrEqual: only applies to numbers public class MyClass { public string StringProperty {get; set;} public int IntegerProperty {get; set;} } var stringRule = new Rule(\"StringProperty\", OperatorType.Equal, \"Some Value\", \"code 1\"); var integerRule = new Rule(\"IntegerProperty\", OperatorType.Equal, \"10\", \"code 2\"); var myObj = new MyClass { StringProperty = \"Some Value\", IntegerProperty = 11 } var result1 = stringRule.Apply(myObj); // returns true var result2 = integerRule.Apply(myObj); // returns false Sample rules with direct operators Internal direct operators Internal direct rules are similar to direct rules, but they are meant to be applied to values that are other fields of the same type; in this case, Value should correspond to the name of another field in the analyzed type: InnerEqual: equality between two value typed fields InnerNotEqual: equality between two value typed fields InnerGreaterThan: only applies when Property and Value are numbers InnerGreaterThanOrEqual: only applies when Property and Value are numbers InnerLessThan: only applies when Property and Value are numbers InnerLessThanOrEqual: only applies when Property and Value are numbers public class MyClass { public string StringProperty1 {get; set;} public string StringProperty2 {get; set;} public int IntegerProperty1 {get; set;} public int IntegerProperty2 {get; set;} } var stringRule = new Rule(\"StringProperty1\", OperatorType.InnerEqual, \"StringProperty2\", \"code 1\"); var integerRule = new Rule(\"IntegerProperty1\", OperatorType.InnerGreaterThan, \"IntegerProperty2\", \"code 2\"); Sample rules with internal direct operators String direct operators These rules are specific to strings: StringStartsWith: checks that the string in Property starts with Value StringEndsWith: checks that the string in Property ends with Value StringContains: checks that the string in Property contains Value StringRegexIsMatch: checks that the string in Property matches Value public class MyClass { public string StringProperty {get; set;} } var stringRule = new Rule(\"StringProperty\", OperatorType.StringStartsWith, \"start\", \"code 1\"); Sample rule with string direct operator Enumerable operators These rules apply to operands of generic enumerable type: Contains: checks that Property contains Value NotContains: checks that Property does not Value Overlaps: checks that Property has a non-empty intersection with Value NotOverlaps: checks that Property has an empty intersection with Value public class MyClass { public IEnumerable<string> StringEnumerableProperty {get; set;} } var rule1 = new Rule(\"StringEnumerableProperty\", OperatorType.Contains, \"value\", \"code 1\"); var rule2 = new Rule(\"StringEnumerableProperty\", OperatorType.Overlaps, \"value1,value2\", \"code 2\"); Sample rules with enumerable operators Internal enumerable operators These operators act on enumerable fields by comparing them against fields of the same type: InnerContains: checks that Property contains the value contained in the property Value InnerNotContains: checks that Property doesn't contain the value contained in the property Value InnerOverlaps: checks that Property has a non-empty intersection with the value contained in the property Value InnerNotOverlaps: checks that Property has an empty intersection with the value contained in the property Value public class MyClass { public IEnumerable<int> EnumerableProperty1 {get; set;} public IEnumerable<int> EnumerableProperty2 {get; set;} public int IntegerField {get; set;} } var rule1 = new Rule(\"EnumerableProperty1\", OperatorType.InnerContains, \"IntegerField\"); var rule2 = new Rule(\"EnumerableProperty1\", OperatorType.InnerOverlaps, \"EnumerableProperty2\"); Sample rules for internal enumerable operators Key-value operators These operators act on dictionary-like objects: ContainsKey: checks that the Property contains the specific key defined by the Value NotContainsKey: checks that the Property doesn't contain the specific key defined by the Value ContainsValue: checks that the dictionary Property contains a value defined by the Value NotContainsValue: checks that the dictionary Property doesn't contain a value defined by the Value KeyContainsValue: checks that the dictionary Property has a key with a specific value NotKeyContainsValue: checks that the dictionary Property doesn't have a key with a specific value public class MyClass { public IDictionary<string, int> DictProperty {get; set;} } var rule1 = new Rule(\"DictProperty\", OperatorType.ContainsKey, \"mykey\"); var rule2 = new Rule(\"DictProperty\", OperatorType.KeyContainsValue, \"mykey[myvalue]\"); sample rules for key-value enumerable operators Inverse enumerable operators These rules apply to scalars against enumerable fields: IsContained: checks that Property is contained in a specific set IsNotContained: checks that Property is not contained in a specific set public class MyClass { public int IntProperty {get; set;} } var rule1 = new Rule(\"IntProperty\", OperatorType.IsContained, \"1,2,3\"); Sample rules for inverse enumerable operators The RulesSets A RulesSet is a set of rules. From a functional point of view, it represents a boolean typed function composed by a set of functions on a given type. DEFINITION: A RulesSet is satisfied by an item t of type T if all the functions of the set are satisfied by t. A RulesSet corresponds to the logical AND operator on its rules. The RulesCatalog A RulesCatalog represents a set of RulesSet, and functionally corresponds to a boolean typed function composed by a set of sets of functions on a given type. DEFINITION: A RulesCatalog is satisfied by an item t of type T if at least one of its RulesSets is satisfied by t. A RulesCatalog corresponds to the logical OR operator on its RulesSets. The Algebraic model As discussed above, composite types RulesSet and RulesCatalog represent logical operations on the field of functions f: T ──► bool; it seems than possible to define an algebraic model defining the composition of different entities. RulesSets product DEFINITION: The product of two RulesSets is a new RulesSet, and its rules are a set of rules obtained by concatenating the rules of the two RulesSets rs1 = {r1, r2, r3} rs2 = {r4, r5} ──► rs1 * rs2 = {r1, r2, r3, r4, r5} product of two RulesSets RulesCatalog sum The sum of two RulesCatalog objects is a RulesCatalog with a set of RulesSet obtained by simply concatenating the two sets of RulesSet: c1 = {rs1, rs2, rs3} c2 = {rs4, rs5} ──► c1 + c2 = {rs1, rs2, rs3, rs4, rs5} sum of two RulesCatalog RulesCatalog product The product of two catalogs is a catalog with a set of all the RulesSet obtained concatenating a set of the first catalog with one of the second. c1 = {rs1, rs2, rs3} c2 = {rs4, rs5} ──► c1 * c2 = {(rs1*rs4), (rs1*rs5), (rs2*rs4), (rs2*rs5), (rs3*rs4), (rs3*rs5)} product of two RulesCatalog Compilers and compiled objects The RuleCompiler is the component that parses and compiles a Rule into executable code. Every rule becomes an Option<CompiledRule<T>>, where the None status of the option corresponds to a Rule that is not formally correct and hence cannot be compiled[^1]. A CompiledRule<T> is the actual portion of code that can be applied to an item of type T to provide a boolean result using its ApplyApply(T item) method. Sometimes the boolean result is not enough: when the rule is not satisfied it could be useful to understand the reason why it failed. For this reason, a dedicated Either<string, Unit> DetailedApply(T item) method returns Unit when the rule is satisfied, or a string (the rule code) in case of failure. Like the RuleCompiler, the RulesSetCompiler transforms a RulesSet into an Option<CompiledRulesSet<T>>. A CompiledRulesSet<T> can logically be seen as a set of compiled rules, hence, when applied to an item of type T it returns a boolean that is true if all the compiled rules return true on it. From a logical point of view, a CompiledRulesSet<T> represents the AND superposition of its CompiledRule<T>. The corresponding Either<string, Unit> DetailedApply(T item) method of the CompiledRulesSet<T> returns Unit when all the rules are satisfied, or the set of codes for the rules that are not. Finally, the RulesCatalogCompiler transforms a RulesCatalog into an Option<CompiledCatalog<T>>, where the None status represents a catalog that cannot be compiled. A CompiledCatalog<T> logically represents the executable code that applies a set of rule sets to an object of type T: the result of its application can be true if at least one set of rules returns true, otherwise false (this represents the logical OR composition operations on rules joined by a logical AND). Similar to the Either<string, Unit> DetailedApply(T item) of the CompiledRulesSet<T>, it can return Unit when at least one internal rule set returns Unit, otherwise the flattened set of all the codes for all the rules that don't successfully apply. Known limitations The current implementation of the rules system has some limitations: it is designed to work on plain objects (instances of classes, records, or structures) with an empty constructor rules can only be applied to 'first level members', no nesting is currently supported Breaking changes If you want to upgrade from a version < 3.0.0 to the latest version you will need to adapt your implementation to manage the breaking changes introduced. The main differences can be condensed in the removal of the managers: the entire logic is now completely captured by the compiled objects CompiledRule<T>, CompiledRulesSet<T>, CompiledCatalog<T>, without the need of external wrappers. This means that the typical workflow to update the library requires: getting the rules definition pass them to the appropriate compiler use the generated compiled objects to validate your objects according to the rules definition How to install the package If you are using nuget.org you can add the dependency in your project using dotnet add package logic-engine --version <version> To install the logic-engine library from GitHub's packages system please refer to the packages page. [^0]: from a technical perspective this is obtained with a concrete implementation of the railway pattern [^1]: null or empty codes are removed because they don't carry reusable info"
  },
  "index.html": {
    "href": "index.html",
    "title": "| Logic Engine",
    "summary": "version 4.4.0 The logic-engine is a lightweight .NET library designed to facilitate dynamic and flexible logic systems. It allows developers to define a generic set of rules that can be compiled into executable code, enabling modifications to business logic without altering the system's core. By leveraging functional programming principles (thanks to Franco Melandri's Tiny FP), it offers tools to evaluate whether an entity satisfies specific conditions and, if not, identify the reasons for failure. Key components include Rules, which are basic logical constructs, RulesSets for combined conditions using logical AND, and RulesCatalog for broader combinations using logical OR. It supports a wide range of operators, from comparisons (e.g., equality, greater-than, etc.) to more complex string and enumerable operations. The library aims to simplify logic handling while maintaining flexibility and clarity in implementation."
  }
}